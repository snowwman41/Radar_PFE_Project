
from pypylon import pylon
import time
import cv2
from concurrent.futures import ThreadPoolExecutor
import os
import glob
from common.enums import *
from pypylon import genicam
from plot_csv_logger.myCsv import MyCsv

from plot_csv_logger.logger import Logger

ROOT_DIR=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

class Camera:
    """ 
    - This class grabs, saves, and reconstutes the images of the cameras .
    - The grab is controlled by the radar, and grabs the most recent frame 
        generated by the cameras.
    - since the camera is slower than radar to start acquisition, the first
        acquisition start when the camera is ready
    - In case more than one camera is attached, and one gets disconnected the 
        program continues running with the cameras left.
                                                                            """

    isRadarInit=False # to wait for radar to start grabbing
    maxCamerasToUse=2 # number of cameras in use
    cameraTimestamps=[] # csv timeStamps of camera
    
    # connecting to available cameras  
    @classmethod  
    def initialize(cls,camRec,myCsv : MyCsv,stopRec,radSend,config):
        cls.camRec=camRec
        cls.stopRec=stopRec        
        cls.myCsv=myCsv
        cls.radSend=radSend
        cls.config=config

        if not Camera.initCameraConfig():
            #send order for radar to start grabbing
            Camera.radSend.send(0) 
            Logger.info("Camera isn't initialized")
            return        
  
        try:
            # Get the transport layer factory.
            tlFactory = pylon.TlFactory.GetInstance()
            # Get all attached devices and exit application if no device is found.
            devices = tlFactory.EnumerateDevices()
            if len(devices) == 0:
                raise pylon.RuntimeException("No camera present.")
            cls.cameras = pylon.InstantCameraArray(min(len(devices), cls.maxCamerasToUse))
            l = cls.cameras.GetSize()
            for i, cam in enumerate(cls.cameras):
                cam.Attach(tlFactory.CreateDevice(devices[i]))
                cam.Open()
                if genicam.IsWritable(cam.ChunkModeActive):
                    # Enable chunks in general.
                    cam.ChunkModeActive.Value = True
                    # Enable time stamp chunks.
                    cam.ChunkSelector.Value = "Timestamp"
                    cam.ChunkEnable.Value = True
                else:
                    raise pylon.RuntimeException("The camera doesn't support chunk features")

            Logger.info("Camera started recording")           

            # Grabing Continusely (video) with minimal delay
            cls.cameras.StartGrabbing(pylon.GrabStrategy_LatestImageOnly)
            cls.converter = pylon.ImageFormatConverter()

            # converting to opencv bgr format
            cls.converter.OutputPixelFormat = pylon.PixelType_BGR8packed
            cls.converter.OutputBitAlignment = pylon.OutputBitAlignment_MsbAligned
        
        except Exception as e:
            #send order for radar to start grabbing 
            Camera.radSend.send(0) 
            print(e)
            Logger.error(e)
            return

        with ThreadPoolExecutor() as executor:
            try:
                while cls.cameras.IsGrabbing(): 
                    if cls.stopRec.poll():  
                        Logger.info("Camera stopped recording")                  
                        break  
                    if cls.grabResults(executor) == 0:                    
                        removed = cls.cameras.IsCameraDeviceRemoved()
                        if removed :
                            # if cam removed try to hold on to one camera to grab, if not present this will error out
                            cls.cameras.StopGrabbing()
                            cls.cameras.Close()
                            Camera.initialize(cls.camRec,cls.myCsv,cls.stopRec,cls.radSend,cls.config)
                            return
                                
                if config.cameraSave== DataMode.SAVE:
                    executor.submit(myCsv.outputCsv,FileType.CAMERA,cls.cameraTimestamps)
            except Exception as e:
                print(e)
                Logger.error("Camera stopped recording")         
    
        # Releasing the resource    
        cls.cameras.StopGrabbing()
        cv2.destroyAllWindows()
        cls.cameras.Close()

            
    @classmethod
    def initCameraConfig(cls):
        if not cls.config.camOn:            
            return False  
        if cls.config.cameraSave == DataMode.SAVE:
            cls.savePath=os.path.join(ROOT_DIR,f"{cls.myCsv.folderName}/images/")        
            if not os.path.exists(cls.savePath):
                os.makedirs(cls.savePath)
        if cls.config.camOn:            
            return True       
        return False    

    @classmethod      
    def grabResults(cls,executor : ThreadPoolExecutor):
        if not Camera.isRadarInit:
            Camera.radSend.send(1) # order radar to start acquisiton
            Camera.isRadarInit = True        
        try:
                        
            if cls.camRec.poll():                                   
                # reset the accumulated requests sent at the start in case there is a difference between radar and camera starting time 
                # which is probably not the case when synchronization is active
                while cls.camRec.poll():
                    # wait for radar request to grab  
                    cls.camRec.recv()
            else :
                return -1

            timestamp=time.perf_counter_ns() 
            grabResult = cls.cameras.RetrieveResult(5000, pylon.TimeoutHandling_ThrowException)
            
        except Exception as e: 
            print(e)
            Logger.error(e)
            return 0
        
        if grabResult.GrabSucceeded():
            image = cls.converter.Convert(grabResult)        
            img = image.GetArray()
            cls.cameraTimestamps.append([timestamp, grabResult.ChunkTimestamp.Value])

            if cls.config.cameraSave== DataMode.SAVE:
                executor.submit(Camera.saveImage,img,f"{grabResult.ChunkTimestamp.Value}_{timestamp}")
                return 1
            elif cls.config.cameraSave== DataMode.PLOT:                               
                cv2.namedWindow('Basler', cv2.WINDOW_NORMAL)
                imgs=cv2.resize(img,(1000,600))
                cv2.imshow('Basler', imgs)
                k = cv2.waitKey(1)
                if k == 27:
                    grabResult.Release()
                    return 27
        grabResult.Release() 
        return 1           
     
    def saveImage(img,timestamp):        
        cv2.imwrite(filename=f"{Camera.savePath}/{timestamp}.jpeg", img=img,params=[cv2.IMWRITE_JPEG_QUALITY,Camera.config.camSaveQuality]) #opencv
    
    


        

